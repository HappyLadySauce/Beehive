# Beehive IM 微服务架构设计

## 概述

Beehive IM 系统采用微服务架构，使用独立的 Auth Service 负责认证授权，其他服务专注于各自的业务领域。本文档详细说明系统的微服务架构设计。

## 架构图

```mermaid
graph TB
    subgraph Clients["客户端层"]
        Web[Web客户端]
        Mobile[移动端]
        API[API客户端]
    end
    
    subgraph Gateway["Gateway 服务<br/>无状态，可水平扩展"]
        WS[WebSocket Gateway<br/>:8080]
        HTTP[HTTP API<br/>:8080]
    end
    
    subgraph Services["业务服务层<br/>gRPC 服务"]
        AS[Auth Service<br/>:50050<br/>认证授权服务]
        US[User Service<br/>:50051<br/>用户数据管理]
        MS[Message Service<br/>:50052<br/>消息服务]
        PS[Presence Service<br/>:50053<br/>在线状态服务]
    end
    
    subgraph Infrastructure["基础设施层"]
        MQ[RabbitMQ<br/>:5672]
        DB[(PostgreSQL<br/>:5432)]
        Redis[(Redis<br/>:6379)]
        Etcd[(etcd<br/>:2379<br/>服务注册中心)]
    end
    
    Web -->|WebSocket| WS
    Mobile -->|WebSocket| WS
    API -->|HTTP| HTTP
    
    WS -->|gRPC| AS
    WS -->|gRPC| US
    WS -->|gRPC| MS
    WS -->|gRPC| PS
    HTTP -->|gRPC| AS
    
    MS -->|Producer| MQ
    WS -->|Consumer| MQ
    
    AS --> Redis
    AS -->|gRPC| US
    US --> DB
    MS --> DB
    PS --> Redis
    PS --> DB
    
    AS -.->|注册/发现| Etcd
    US -.->|注册/发现| Etcd
    MS -.->|注册/发现| Etcd
    PS -.->|注册/发现| Etcd
    WS -.->|服务发现| Etcd
```

## 微服务划分

### 1. Gateway 服务

**职责**：
- WebSocket 连接管理
- 客户端消息接收和路由
- 消息推送（从 RabbitMQ 消费）
- HTTP API（健康检查、管理接口）
- 请求认证（调用 Auth Service）

**技术栈**：
- gorilla/websocket
- gRPC Client
- RabbitMQ Consumer

**端口**：8080

**特点**：
- 无状态服务
- 支持水平扩展
- 每个实例独立管理连接

**数据**：无持久化数据，仅内存连接管理

### 2. Auth Service

**职责**：
- 用户登录和认证
- JWT Token 生成和验证
- Token 刷新和撤销
- 用户权限验证
- Token 黑名单管理

**技术栈**：
- gRPC Server
- JWT
- Redis（Token 缓存和黑名单）
- gRPC Client（调用 User Service）
- etcd（服务注册和发现）

**端口**：50050

**数据**：
- Redis（Token 缓存、黑名单）
- 通过 gRPC 调用 User Service 获取用户信息

**特点**：
- 无状态服务（可水平扩展）
- 高性能 Token 验证
- 支持多种认证方式（JWT、Refresh Token）

**关键 RPC**：
- `Login(id, password)` - 用户登录
- `ValidateToken(token)` - 验证 Token
- `RefreshToken(refresh_token)` - 刷新 Token
- `RevokeToken(token)` - 撤销 Token

### 3. User Service

**职责**：
- 用户注册
- 用户信息查询和更新
- 用户资料管理
- 用户状态管理

**技术栈**：
- gRPC Server
- GORM
- etcd（服务注册）

**端口**：50051

**数据表**：
- `users`

**特点**：
- 有状态服务（数据库）
- 支持数据库迁移
- 专注于用户数据管理

**关键 RPC**：
- `Register(nickname, avatar, email, description, password)` - 用户注册
- `GetUser(id)` - 获取用户信息
- `GetUserByID(id)` - 获取用户信息（供 Auth Service 调用，包含密码哈希）
- `UpdateUser(id, nickname, avatar, description)` - 更新用户信息

### 4. Message Service

**职责**：
- 单聊消息发送
- 群聊消息发送
- 消息历史查询
- 未读消息管理
- 消息状态更新
- 会话管理

**技术栈**：
- gRPC Server
- GORM
- RabbitMQ Producer

**端口**：50052

**数据表**：
- `messages`
- `conversations`

**特点**：
- 有状态服务（数据库）
- 消息队列生产者
- 支持数据库迁移

**关键 RPC**：
- `SendMessage(from_id, to_id, content, message_type)` - 发送单聊消息
- `SendGroupMessage(from_id, group_id, content, message_type)` - 发送群聊消息
- `GetMessageHistory(id, target_user_id, group_id, limit, offset)` - 获取消息历史
- `GetUnreadMessages(id, target_user_id, group_id)` - 获取未读消息
- `MarkAsRead(id, message_ids, conversation_id)` - 标记消息为已读
- `GetConversations(id, limit, offset)` - 获取会话列表
- `GetConversation(conversation_id)` - 获取会话详情

### 5. Presence Service

**职责**：
- 用户在线状态管理
- 用户上线/下线通知
- 在线用户查询
- 用户详细状态查询

**技术栈**：
- gRPC Server
- Redis
- RabbitMQ Producer（可选）

**端口**：50053

**数据**：
- Redis（在线状态缓存）

**特点**：
- 轻量级服务
- 主要依赖 Redis
- 高性能状态查询

**关键 RPC**：
- `UserOnline(id)` - 用户上线
- `UserOffline(id)` - 用户下线
- `GetOnlineUsers(user_ids)` - 批量获取用户在线状态
- `IsUserOnline(id)` - 检查用户是否在线
- `GetUserPresence(id)` - 获取用户详细在线状态

## 服务间通信

### Gateway 到业务服务

Gateway 通过 gRPC 调用业务服务，使用 etcd 服务发现：

```go
// internal/gateway/grpc/client.go
type Client struct {
    authService    pb.AuthServiceClient
    userService    pb.UserServiceClient
    messageService pb.MessageServiceClient
    presenceService pb.PresenceServiceClient
}

func NewClient(cfg *config.Config) (*Client, error) {
    // 注册 etcd 解析器
    resolver.Register(registry.NewResolverBuilder(cfg.Registry))
    
    // 使用 etcd 服务发现连接 Auth Service
    authConn, err := grpc.NewClient(
        "etcd://beehive-auth",
        grpc.WithTransportCredentials(insecure.NewCredentials()),
    )
    if err != nil {
        return nil, err
    }
    
    // 连接其他服务...
    
    return &Client{
        authService: pb.NewAuthServiceClient(authConn),
        // ...
    }, nil
}
```

### Auth Service 到 User Service

Auth Service 在登录时调用 User Service 获取用户信息，通过 etcd 服务发现：

```go
// Auth Service 登录流程
func (s *Service) Login(ctx context.Context, req *pb.LoginRequest) (*pb.LoginResponse, error) {
    // 1. 调用 User Service 获取用户信息（包含密码哈希）
    // User Service 客户端通过 etcd://beehive-user 自动发现服务
    userReq := &userpb.GetUserByIDRequest{Id: req.Id}
    userResp, err := s.userService.GetUserByID(ctx, userReq)
    if err != nil {
        return nil, status.Error(codes.Unauthenticated, "invalid credentials")
    }
    
    // 2. 验证密码
    // 3. 生成 Token
    // 4. 返回响应
}
```

### 消息队列通信

Message Service 作为 Producer，Gateway 作为 Consumer：

```go
// Message Service 发送消息
producer.PublishSingleChatMessage(userID, message)

// Gateway 消费消息
consumer.ConsumeSingleChatMessages()
```

## 认证流程

### 用户注册流程

```
客户端 → Gateway → User Service: Register
User Service → 数据库: 创建用户
User Service → 客户端: 返回 user_id
客户端 → Gateway → Auth Service: Login(user_id, password)
Auth Service → User Service: GetUserByID(user_id)
Auth Service → Redis: 缓存 Token
Auth Service → 客户端: 返回 token + refresh_token
```

### 用户登录流程

```
客户端 → Gateway → Auth Service: Login(id, password)
Auth Service → User Service: GetUserByID(id)
User Service → 数据库: 查询用户
User Service → Auth Service: 返回用户信息（含密码哈希）
Auth Service: 验证密码
Auth Service → Redis: 缓存 Token
Auth Service → 客户端: 返回 token + refresh_token + user
```

### Token 验证流程

```
客户端 → Gateway: WebSocket 连接（Header: Authorization: Bearer token）
Gateway → Auth Service: ValidateToken(token)
Auth Service → Redis: 检查 Token 缓存/黑名单
Auth Service → User Service: GetUser(id)（如果需要）
Auth Service → Gateway: 返回用户信息
Gateway: 建立 WebSocket 连接
```

## 服务注册与发现

### etcd 服务注册中心

系统使用 etcd 作为服务注册中心，实现服务自动注册和发现：

- **服务注册**：服务启动时自动注册到 etcd
- **服务发现**：通过服务名从 etcd 发现可用服务实例
- **负载均衡**：使用轮询（Round Robin）策略选择服务实例
- **健康检查**：通过 etcd 租约（Lease）机制实现自动健康检查

### 服务注册格式

etcd Key 格式：`/beehive/services/{service_name}/{instance_id}`

服务信息（JSON）：
```json
{
  "service_name": "beehive-auth",
  "address": "localhost",
  "port": 50050,
  "instance_id": "auth-abc12345",
  "metadata": {}
}
```

### 服务发现使用

gRPC 客户端使用 etcd 服务发现：
```
etcd://beehive-auth
etcd://beehive-user
etcd://beehive-message
etcd://beehive-presence
```

## 配置管理

### 配置文件示例

```yaml
# configs/gateway.yaml
server:
  gateway_port: 8080

rabbitmq:
  url: amqp://guest:guest@localhost:5672/

grpc:
  bind-address: "0.0.0.0"
  bind-port: 8080

etcd:
  endpoints: ["localhost:2379"]
  dial-timeout: 5s
  prefix: "/beehive/services"

log:
  level: info
  format: json
```

```yaml
# configs/auth-service.yaml
grpc:
  bind-address: "0.0.0.0"
  bind-port: 50050

jwt:
  secret: your-secret-key-change-in-production
  expire_hours: 24
  refresh_expire_hours: 168  # 7 days

redis:
  addr: localhost:6379
  password: ""
  db: 0

etcd:
  endpoints: ["localhost:2379"]
  dial-timeout: 5s
  prefix: "/beehive/services"

user-service:
  addr: "etcd://beehive-user"  # 使用 etcd 服务发现

log:
  level: info
  format: json
```

```yaml
# configs/user-service.yaml
grpc:
  bind-address: "0.0.0.0"
  bind-port: 50051

database:
  host: localhost
  port: 5432
  user: postgres
  password: postgres
  dbname: beehive
  sslmode: disable

etcd:
  endpoints: ["localhost:2379"]
  dial-timeout: 5s
  prefix: "/beehive/services"

log:
  level: info
  format: json
```

## 部署建议

### 开发环境

- 所有服务运行在同一台机器
- 使用 Docker Compose 管理基础设施
- 使用 `go run` 启动服务

### 生产环境

- 每个服务独立部署
- 使用 Kubernetes 或 Docker Swarm 编排
- 使用配置中心管理配置
- 使用 etcd 实现服务发现和负载均衡
- etcd 集群部署（3节点或5节点）保证高可用

### 监控和日志

- 每个服务暴露健康检查接口
- 统一日志格式（JSON）
- 集成 Prometheus 指标
- 使用分布式追踪（Jaeger）

## 最佳实践

1. **配置管理**：使用环境变量覆盖配置文件
2. **错误处理**：统一的错误码和错误信息
3. **日志记录**：结构化日志，包含请求ID
4. **优雅关闭**：正确处理信号，等待请求完成
5. **健康检查**：实现 `/health` 和 `/ready` 接口
6. **版本管理**：使用 Git 标签管理版本号
7. **文档**：为每个命令添加清晰的帮助信息

## 参考

- [用户登录与操作逻辑](./01-用户登录与操作逻辑.md)
- [Auth 认证架构设计](./02-Auth认证架构设计.md)
- [消息队列设计](./03-消息队列设计.md)
