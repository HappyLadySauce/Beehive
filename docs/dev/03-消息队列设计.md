# 消息队列设计

## 概述

Beehive IM 系统使用 RabbitMQ 作为消息队列，实现消息的异步处理和推送。本文档详细说明消息队列的架构设计、Exchange 和 Queue 配置、消息路由策略等。

## 架构设计

### 消息流转图

```mermaid
graph LR
    subgraph MessageService["Message Service"]
        Producer[Producer]
    end
    
    subgraph RabbitMQ["RabbitMQ"]
        DirectExchange[Direct Exchange<br/>im.direct]
        TopicExchange[Topic Exchange<br/>im.topic]
        SingleQueue[Single Chat Queue]
        GroupQueue[Group Chat Queue]
    end
    
    subgraph Gateway["Gateway Service"]
        Consumer[Consumer]
    end
    
    Producer -->|Publish| DirectExchange
    Producer -->|Publish| TopicExchange
    DirectExchange -->|Route| SingleQueue
    TopicExchange -->|Route| GroupQueue
    SingleQueue -->|Consume| Consumer
    GroupQueue -->|Consume| Consumer
    Consumer -->|Push| Client[客户端]
```

## Exchange 和 Queue 配置

### 1. Direct Exchange（单聊消息）

**Exchange 名称**：`im.direct`

**用途**：单聊消息的点对点路由

**Routing Key 规则**：`user.{user_id}`

**Queue 配置**：
- Queue 名称：`single_chat.{user_id}`
- 绑定规则：`user.{user_id}` → `single_chat.{user_id}`
- 持久化：是
- 自动删除：否

**消息格式**：
```json
{
    "message_id": "msg_123",
    "type": "single",
    "from_id": "user_001",
    "to_id": "user_002",
    "content": "Hello",
    "message_type": "text",
    "status": "sent",
    "created_at": 1234567890
}
```

### 2. Topic Exchange（群聊消息）

**Exchange 名称**：`im.topic`

**用途**：群聊消息的广播路由

**Routing Key 规则**：`group.{group_id}`

**Queue 配置**：
- Queue 名称：`group_chat.{group_id}`
- 绑定规则：`group.{group_id}` → `group_chat.{group_id}`
- 持久化：是
- 自动删除：否

**消息格式**：
```json
{
    "message_id": "msg_456",
    "type": "group",
    "from_id": "user_001",
    "group_id": "group_001",
    "content": "Hello all",
    "message_type": "text",
    "status": "sent",
    "created_at": 1234567890
}
```

## 消息路由策略

### 单聊消息路由

```mermaid
sequenceDiagram
    participant Client as 客户端
    participant Gateway as Gateway
    participant MsgSvc as Message Service
    participant MQ as RabbitMQ
    participant Consumer as Gateway Consumer
    participant Target as 目标客户端
    
    Client->>Gateway: 发送单聊消息
    Gateway->>MsgSvc: gRPC: SendMessage
    MsgSvc->>MsgSvc: 保存消息到数据库
    MsgSvc->>MQ: Publish to im.direct<br/>Routing: user.{to_id}
    MsgSvc-->>Gateway: 返回成功
    Gateway-->>Client: 返回消息ID
    
    Note over MQ,Consumer: 异步处理
    MQ->>Consumer: 消费消息（routing: user.{to_id}）
    Consumer->>Consumer: 查找用户连接
    alt 用户在线
        Consumer->>Target: WebSocket 推送消息
        Consumer->>MsgSvc: 更新消息状态为 delivered
    else 用户离线
        Consumer->>MsgSvc: 更新消息状态为 unread
    end
```

### 群聊消息路由

```mermaid
sequenceDiagram
    participant Client as 客户端
    participant Gateway as Gateway
    participant MsgSvc as Message Service
    participant MQ as RabbitMQ
    participant Consumer as Gateway Consumer
    participant Members as 群组成员
    
    Client->>Gateway: 发送群聊消息
    Gateway->>MsgSvc: gRPC: SendGroupMessage
    MsgSvc->>MsgSvc: 保存消息到数据库
    MsgSvc->>MQ: Publish to im.topic<br/>Routing: group.{group_id}
    MsgSvc-->>Gateway: 返回成功
    Gateway-->>Client: 返回消息ID
    
    Note over MQ,Consumer: 异步处理
    MQ->>Consumer: 消费消息（routing: group.{group_id}）
    Consumer->>MsgSvc: 查询群组所有成员
    Consumer->>Consumer: 查找在线成员连接
    loop 每个在线成员
        Consumer->>Members: WebSocket 推送消息
    end
    Consumer->>MsgSvc: 更新离线成员消息状态为 unread
```

## 实现代码

### Producer（Message Service）

```go
// internal/mq/producer.go
package mq

import (
    "encoding/json"
    "github.com/rabbitmq/amqp091-go"
)

type Producer struct {
    conn    *amqp091.Connection
    channel *amqp091.Channel
}

func NewProducer(url string) (*Producer, error) {
    conn, err := amqp091.Dial(url)
    if err != nil {
        return nil, err
    }
    
    ch, err := conn.Channel()
    if err != nil {
        return nil, err
    }
    
    // 声明 Direct Exchange（单聊）
    err = ch.ExchangeDeclare(
        "im.direct",  // name
        "direct",     // type
        true,         // durable
        false,        // auto-deleted
        false,        // internal
        false,        // no-wait
        nil,          // arguments
    )
    
    // 声明 Topic Exchange（群聊）
    err = ch.ExchangeDeclare(
        "im.topic",   // name
        "topic",      // type
        true,         // durable
        false,        // auto-deleted
        false,        // internal
        false,        // no-wait
        nil,          // arguments
    )
    
    return &Producer{
        conn:    conn,
        channel: ch,
    }, nil
}

// PublishSingleChatMessage 发布单聊消息
func (p *Producer) PublishSingleChatMessage(toID string, message *pb.Message) error {
    routingKey := fmt.Sprintf("user.%s", toID)
    
    body, err := json.Marshal(message)
    if err != nil {
        return err
    }
    
    return p.channel.Publish(
        "im.direct",  // exchange
        routingKey,    // routing key
        false,        // mandatory
        false,        // immediate
        amqp091.Publishing{
            ContentType:  "application/json",
            Body:         body,
            DeliveryMode: amqp091.Persistent, // 持久化
        },
    )
}

// PublishGroupMessage 发布群聊消息
func (p *Producer) PublishGroupMessage(groupID string, message *pb.Message) error {
    routingKey := fmt.Sprintf("group.%s", groupID)
    
    body, err := json.Marshal(message)
    if err != nil {
        return err
    }
    
    return p.channel.Publish(
        "im.topic",    // exchange
        routingKey,    // routing key
        false,        // mandatory
        false,        // immediate
        amqp091.Publishing{
            ContentType:  "application/json",
            Body:         body,
            DeliveryMode: amqp091.Persistent, // 持久化
        },
    )
}
```

### Consumer（Gateway Service）

```go
// internal/mq/consumer.go
package mq

import (
    "encoding/json"
    "github.com/rabbitmq/amqp091-go"
)

type Consumer struct {
    conn     *amqp091.Connection
    channel  *amqp091.Channel
    connMgr  *connection.Manager
    msgSvc   pb.MessageServiceClient
}

func NewConsumer(url string, connMgr *connection.Manager, msgSvc pb.MessageServiceClient) (*Consumer, error) {
    conn, err := amqp091.Dial(url)
    if err != nil {
        return nil, err
    }
    
    ch, err := conn.Channel()
    if err != nil {
        return nil, err
    }
    
    return &Consumer{
        conn:    conn,
        channel: ch,
        connMgr: connMgr,
        msgSvc:  msgSvc,
    }, nil
}

// ConsumeSingleChatMessages 消费单聊消息
func (c *Consumer) ConsumeSingleChatMessages() error {
    // 声明队列（使用通配符绑定所有用户）
    q, err := c.channel.QueueDeclare(
        "single_chat_gateway", // name
        true,                  // durable
        false,                 // delete when unused
        false,                 // exclusive
        false,                 // no-wait
        amqp091.Table{
            "x-message-ttl": 86400000, // 24小时过期
        },
    )
    
    // 绑定到 Direct Exchange
    err = c.channel.QueueBind(
        q.Name,      // queue name
        "user.*",    // routing key pattern
        "im.direct", // exchange
        false,
        nil,
    )
    
    msgs, err := c.channel.Consume(
        q.Name, // queue
        "",     // consumer
        false,  // auto-ack
        false,  // exclusive
        false,  // no-local
        false,  // no-wait
        nil,    // args
    )
    
    go func() {
        for d := range msgs {
            var message pb.Message
            if err := json.Unmarshal(d.Body, &message); err != nil {
                log.Printf("Failed to unmarshal message: %v", err)
                d.Nack(false, true) // 重新入队
                continue
            }
            
            // 查找用户连接
            conns := c.connMgr.GetUserConnections(message.ToId)
            if len(conns) > 0 {
                // 用户在线，推送消息
                for _, conn := range conns {
                    c.pushMessage(conn, &message)
                }
                // 更新消息状态为已送达
                c.updateMessageStatus(message.Id, "delivered")
            } else {
                // 用户离线，保持未读状态
            }
            
            d.Ack(false)
        }
    }()
    
    return nil
}

// ConsumeGroupMessages 消费群聊消息
func (c *Consumer) ConsumeGroupMessages() error {
    // 声明队列
    q, err := c.channel.QueueDeclare(
        "group_chat_gateway", // name
        true,                 // durable
        false,                // delete when unused
        false,                // exclusive
        false,                // no-wait
        nil,
    )
    
    // 绑定到 Topic Exchange
    err = c.channel.QueueBind(
        q.Name,       // queue name
        "group.*",    // routing key pattern
        "im.topic",   // exchange
        false,
        nil,
    )
    
    msgs, err := c.channel.Consume(
        q.Name, // queue
        "",     // consumer
        false,  // auto-ack
        false,  // exclusive
        false,  // no-local
        false,  // no-wait
        nil,    // args
    )
    
    go func() {
        for d := range msgs {
            var message pb.Message
            if err := json.Unmarshal(d.Body, &message); err != nil {
                log.Printf("Failed to unmarshal message: %v", err)
                d.Nack(false, true)
                continue
            }
            
            // 查询群组所有成员
            members := c.getGroupMembers(message.GroupId)
            
            // 推送消息给在线成员
            for _, memberID := range members {
                conns := c.connMgr.GetUserConnections(memberID)
                for _, conn := range conns {
                    c.pushMessage(conn, &message)
                }
            }
            
            d.Ack(false)
        }
    }()
    
    return nil
}
```

## 消息可靠性

### 1. 消息持久化

- **Exchange 持久化**：所有 Exchange 设置为 durable
- **Queue 持久化**：所有 Queue 设置为 durable
- **消息持久化**：消息 DeliveryMode 设置为 Persistent

### 2. 消息确认

- **Producer 确认**：使用 Publisher Confirms 确保消息发送成功
- **Consumer 确认**：手动 ACK，确保消息处理完成

### 3. 消息重试

- **失败重试**：消息处理失败时，使用 Nack 重新入队
- **重试次数限制**：限制重试次数，避免无限重试
- **死信队列**：超过重试次数的消息进入死信队列

## 性能优化

### 1. 批量处理

- **批量消费**：批量消费消息，减少网络开销
- **批量推送**：批量推送消息给客户端

### 2. 连接复用

- **连接池**：使用连接池管理 RabbitMQ 连接
- **Channel 复用**：复用 Channel，减少创建开销

### 3. 消息压缩

- **消息压缩**：对大型消息进行压缩
- **内容优化**：优化消息内容，减少消息大小

## 监控和告警

### 1. 监控指标

- 消息生产速率
- 消息消费速率
- 队列长度
- 消息处理延迟
- 消息丢失率

### 2. 告警规则

- 队列长度超过阈值
- 消息处理延迟过高
- 消息丢失率过高
- Consumer 连接断开

## 配置示例

```yaml
# configs/message-service.yaml
rabbitmq:
  url: amqp://guest:guest@localhost:5672/

# configs/gateway.yaml
rabbitmq:
  url: amqp://guest:guest@localhost:5672/
```

## 参考

- [微服务架构设计](./00-微服务架构设计.md)
- [用户登录与操作逻辑](./01-用户登录与操作逻辑.md)
- [Auth 认证架构设计](./02-Auth认证架构设计.md)
