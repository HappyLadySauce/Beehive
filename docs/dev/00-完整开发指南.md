# Beehive IM 系统完整开发指南

## 概述

本文档提供从零开始构建 Beehive IM 系统的完整开发指南，包含每个阶段的详细步骤、代码示例和检查点。

## 微服务架构

Beehive IM 系统采用微服务架构，使用 Cobra 命令行框架构建，包含以下微服务：

### 微服务划分

```mermaid
graph TB
    subgraph Clients["客户端"]
        Web[Web客户端]
        Mobile[移动端]
    end
    
    subgraph Gateway["Gateway 服务"]
        WS[WebSocket Gateway<br/>端口: 8080]
    end
    
    subgraph Services["业务服务层"]
        US[User Service<br/>端口: 50051<br/>用户认证、注册、信息管理]
        MS[Message Service<br/>端口: 50052<br/>消息发送、历史查询]
        PS[Presence Service<br/>端口: 50053<br/>在线状态管理]
    end
    
    subgraph Infrastructure["基础设施层"]
        MQ[RabbitMQ<br/>消息队列]
        DB[(PostgreSQL<br/>数据库)]
        Redis[(Redis<br/>缓存)]
    end
    
    Web --> WS
    Mobile --> WS
    WS -->|gRPC| US
    WS -->|gRPC| MS
    WS -->|gRPC| PS
    MS --> MQ
    PS --> Redis
    US --> DB
    MS --> DB
    PS --> DB
```

### 微服务职责

#### 1. Gateway 服务
- **职责**：WebSocket 连接管理、消息路由、客户端通信
- **端口**：8080 (HTTP/WebSocket)
- **技术**：gorilla/websocket, gRPC Client
- **特点**：无状态，可水平扩展

#### 2. User Service
- **职责**：用户注册、登录、认证、用户信息管理
- **端口**：50051 (gRPC)
- **技术**：gRPC Server, JWT, GORM
- **数据**：users 表

#### 3. Message Service
- **职责**：消息发送、消息历史、未读消息、消息状态管理
- **端口**：50052 (gRPC)
- **技术**：gRPC Server, RabbitMQ Producer, GORM
- **数据**：messages, conversations, groups, group_members 表

#### 4. Presence Service
- **职责**：在线状态管理、用户上线/下线通知
- **端口**：50053 (gRPC)
- **技术**：gRPC Server, Redis, RabbitMQ Producer
- **数据**：Redis (在线状态缓存)

### Cobra 框架架构

每个微服务使用 Cobra 框架构建，统一的命令结构：

```
beehive-{service}
├── serve          # 启动服务
├── migrate        # 数据库迁移（仅 User/Message Service）
├── version        # 显示版本信息
└── config         # 配置相关命令
    ├── validate   # 验证配置文件
    └── show       # 显示配置
```

## 开发阶段概览

```mermaid
gantt
    title 开发阶段时间线
    dateFormat  YYYY-MM-DD
    section 基础搭建
    环境配置           :a1, 2024-01-01, 1d
    项目结构           :a2, after a1, 1d
    数据库设计         :a3, after a2, 2d
    section 核心功能
    Protocol Buffers  :b1, after a3, 2d
    数据模型           :b2, after b1, 2d
    gRPC服务          :b3, after b2, 5d
    section Gateway
    Connection Manager :c1, after b3, 2d
    WebSocket Gateway  :c2, after c1, 3d
    section 消息队列
    RabbitMQ集成     :d1, after c2, 3d
    消息路由          :d2, after d1, 2d
    section 测试优化
    单元测试          :e1, after d2, 3d
    集成测试          :e2, after e1, 2d
    性能优化          :e3, after e2, 2d
```

## 阶段一：项目基础搭建（第1-4天）

### 1.1 环境准备

#### 1.1.1 安装必要工具

```bash
# 检查 Go 版本（需要 1.25+）
go version

# 安装 Protocol Buffers 编译器
# macOS
brew install protobuf

# Linux
sudo apt-get install protobuf-compiler

# 安装 Go 插件
go install google.golang.org/protobuf/cmd/protoc-gen-go@latest
go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest

# 安装 Air（热重载工具，可选）
go install github.com/cosmtrek/air@latest
```

#### 1.1.2 创建项目结构

```bash
cd /opt/Beehive

# 创建目录结构
mkdir -p api/proto
mkdir -p cmd/{gateway,user-service,message-service,presence-service}
mkdir -p internal/{gateway/{websocket,connection},service/{user,message,presence},mq,pkg/{model,db,config,utils}}
mkdir -p pkg/{options,utils}
mkdir -p scripts
mkdir -p docker
mkdir -p docs/dev
mkdir -p configs
```

**项目结构说明：**

```
Beehive/
├── api/
│   └── proto/                    # Protocol Buffers 定义文件
├── cmd/                          # 微服务入口（Cobra 命令）
│   ├── gateway/                  # Gateway 服务
│   │   ├── main.go              # 主入口
│   │   └── cmd/                 # Cobra 命令定义
│   ├── user-service/            # User Service
│   │   ├── main.go
│   │   └── cmd/
│   ├── message-service/         # Message Service
│   │   ├── main.go
│   │   └── cmd/
│   └── presence-service/        # Presence Service
│       ├── main.go
│       └── cmd/
├── internal/                     # 内部实现（不对外暴露）
│   ├── gateway/                 # Gateway 服务实现
│   │   ├── websocket/          # WebSocket 处理
│   │   └── connection/         # 连接管理
│   ├── service/                # gRPC 服务实现
│   │   ├── user/              # User Service 实现
│   │   ├── message/           # Message Service 实现
│   │   └── presence/          # Presence Service 实现
│   ├── mq/                     # 消息队列
│   │   ├── producer.go
│   │   ├── consumer.go
│   │   └── config.go
│   └── pkg/                    # 内部共享包
│       ├── model/              # 数据模型
│       ├── db/                 # 数据库连接
│       └── config/             # 配置管理
├── pkg/                         # 对外共享包
│   ├── options/                # 命令行选项（Cobra）
│   └── utils/                  # 工具函数
├── configs/                     # 配置文件目录
│   ├── gateway.yaml
│   ├── user-service.yaml
│   ├── message-service.yaml
│   └── presence-service.yaml
├── scripts/                     # 脚本文件
├── docker/                      # Docker 配置
└── docs/                        # 文档
```

#### 1.1.3 初始化 Go 模块

```bash
# 初始化 go.mod（如果还没有）
go mod init github.com/HappyLadySauce/Beehive

# 添加核心依赖
go get google.golang.org/grpc
go get google.golang.org/protobuf
go get github.com/gorilla/websocket
go get github.com/rabbitmq/amqp091-go
go get gorm.io/gorm
go get gorm.io/driver/postgres
go get gorm.io/driver/mysql
go get github.com/golang-jwt/jwt/v5
go get github.com/spf13/viper
go get github.com/spf13/cobra
go get github.com/spf13/pflag
go get github.com/google/uuid
go get github.com/redis/go-redis/v9
go get go.uber.org/zap
```

### 1.2 Docker 环境配置

#### 1.2.1 创建 docker-compose.yml

```yaml
# docker/docker-compose.yml
version: '3.8'

services:
  postgres:
    image: postgres:15-alpine
    container_name: beehive-postgres
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: beehive
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 10s
      timeout: 5s
      retries: 5

  rabbitmq:
    image: rabbitmq:3-management-alpine
    container_name: beehive-rabbitmq
    environment:
      RABBITMQ_DEFAULT_USER: guest
      RABBITMQ_DEFAULT_PASS: guest
    ports:
      - "5672:5672"   # AMQP 端口
      - "15672:15672" # 管理界面
    volumes:
      - rabbitmq_data:/var/lib/rabbitmq
    healthcheck:
      test: ["CMD", "rabbitmq-diagnostics", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5

  redis:
    image: redis:7-alpine
    container_name: beehive-redis
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5

volumes:
  postgres_data:
  rabbitmq_data:
  redis_data:
```

#### 1.2.2 启动基础设施

```bash
cd docker
docker-compose up -d

# 验证服务状态
docker-compose ps

# 访问 RabbitMQ 管理界面
# http://localhost:15672 (guest/guest)
```

### 1.3 配置文件管理

#### 1.3.1 创建配置结构

```go
// internal/pkg/config/config.go
package config

import (
    "github.com/spf13/viper"
    "log"
)

type Config struct {
    Server   ServerConfig
    Database DatabaseConfig
    RabbitMQ RabbitMQConfig
    Redis    RedisConfig
    JWT      JWTConfig
    Log      LogConfig
}

type ServerConfig struct {
    GatewayPort     int
    UserServicePort int
    MessageServicePort int
    PresenceServicePort int
}

type DatabaseConfig struct {
    Host     string
    Port     int
    User     string
    Password string
    DBName   string
    SSLMode  string
}

type RabbitMQConfig struct {
    URL string
}

type RedisConfig struct {
    Addr     string
    Password string
    DB       int
}

type JWTConfig struct {
    Secret     string
    ExpireHours int
}

type LogConfig struct {
    Level  string
    Format string
}

var GlobalConfig *Config

func LoadConfig(configPath string) (*Config, error) {
    viper.SetConfigName("config")
    viper.SetConfigType("yaml")
    viper.AddConfigPath(configPath)
    viper.AddConfigPath(".")
    viper.AddConfigPath("./config")
    
    // 环境变量支持
    viper.SetEnvPrefix("BEEHIVE")
    viper.AutomaticEnv()
    
    // 默认值
    setDefaults()
    
    if err := viper.ReadInConfig(); err != nil {
        log.Printf("Config file not found, using defaults: %v", err)
    }
    
    var config Config
    if err := viper.Unmarshal(&config); err != nil {
        return nil, err
    }
    
    GlobalConfig = &config
    return &config, nil
}

func setDefaults() {
    viper.SetDefault("server.gateway_port", 8080)
    viper.SetDefault("server.user_service_port", 50051)
    viper.SetDefault("server.message_service_port", 50052)
    viper.SetDefault("server.presence_service_port", 50053)
    
    viper.SetDefault("database.host", "localhost")
    viper.SetDefault("database.port", 5432)
    viper.SetDefault("database.user", "postgres")
    viper.SetDefault("database.password", "postgres")
    viper.SetDefault("database.dbname", "beehive")
    viper.SetDefault("database.sslmode", "disable")
    
    viper.SetDefault("rabbitmq.url", "amqp://guest:guest@localhost:5672/")
    
    viper.SetDefault("redis.addr", "localhost:6379")
    viper.SetDefault("redis.password", "")
    viper.SetDefault("redis.db", 0)
    
    viper.SetDefault("jwt.secret", "your-secret-key-change-in-production")
    viper.SetDefault("jwt.expire_hours", 24)
    
    viper.SetDefault("log.level", "info")
    viper.SetDefault("log.format", "json")
}
```

#### 1.3.2 创建配置文件

```yaml
# config/config.yaml
server:
  gateway_port: 8080
  user_service_port: 50051
  message_service_port: 50052
  presence_service_port: 50053

database:
  host: localhost
  port: 5432
  user: postgres
  password: postgres
  dbname: beehive
  sslmode: disable

rabbitmq:
  url: amqp://guest:guest@localhost:5672/

redis:
  addr: localhost:6379
  password: ""
  db: 0

jwt:
  secret: your-secret-key-change-in-production
  expire_hours: 24

log:
  level: info
  format: json
```

**检查点 1.1**：验证环境配置
- [ ] Go 环境正常
- [ ] Docker 服务运行正常
- [ ] 配置文件加载成功
- [ ] 可以连接到数据库和 RabbitMQ

## 阶段二：数据库设计（第5-6天）

### 2.1 数据库表设计

#### 2.1.1 用户表（users）

```sql
-- scripts/schema.sql
CREATE TABLE IF NOT EXISTS users (
    id VARCHAR(36) PRIMARY KEY,
    username VARCHAR(32) UNIQUE NOT NULL,
    nickname VARCHAR(32) NOT NULL,
    avatar VARCHAR(255) NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    salt VARCHAR(64) NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    level INTEGER NOT NULL DEFAULT 1,
    status VARCHAR(20) NOT NULL DEFAULT 'active',
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_users_username ON users(username);
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_status ON users(status);
```

#### 2.1.2 消息表（messages）

```sql
CREATE TABLE IF NOT EXISTS messages (
    id VARCHAR(36) PRIMARY KEY,
    type VARCHAR(20) NOT NULL, -- 'single' or 'group'
    from_user_id VARCHAR(36) NOT NULL,
    to_user_id VARCHAR(36), -- NULL for group messages
    group_id VARCHAR(36), -- NULL for single messages
    content TEXT NOT NULL,
    message_type VARCHAR(20) NOT NULL DEFAULT 'text', -- 'text', 'image', 'file'
    status VARCHAR(20) NOT NULL DEFAULT 'sent', -- 'sent', 'delivered', 'read', 'unread'
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_messages_from_user ON messages(from_user_id);
CREATE INDEX idx_messages_to_user ON messages(to_user_id);
CREATE INDEX idx_messages_group ON messages(group_id);
CREATE INDEX idx_messages_created ON messages(created_at);
CREATE INDEX idx_messages_status ON messages(status);
CREATE INDEX idx_messages_conversation ON messages(from_user_id, to_user_id, created_at);
```

#### 2.1.3 群组表（groups）

```sql
CREATE TABLE IF NOT EXISTS groups (
    id VARCHAR(36) PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    avatar VARCHAR(255),
    description TEXT,
    owner_id VARCHAR(36) NOT NULL,
    status VARCHAR(20) NOT NULL DEFAULT 'active',
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_groups_owner ON groups(owner_id);
CREATE INDEX idx_groups_status ON groups(status);
```

#### 2.1.4 群组成员表（group_members）

```sql
CREATE TABLE IF NOT EXISTS group_members (
    id VARCHAR(36) PRIMARY KEY,
    group_id VARCHAR(36) NOT NULL,
    user_id VARCHAR(36) NOT NULL,
    role VARCHAR(20) NOT NULL DEFAULT 'member', -- 'owner', 'admin', 'member'
    status VARCHAR(20) NOT NULL DEFAULT 'active',
    joined_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(group_id, user_id)
);

CREATE INDEX idx_group_members_group ON group_members(group_id);
CREATE INDEX idx_group_members_user ON group_members(user_id);
CREATE INDEX idx_group_members_status ON group_members(status);
```

#### 2.1.5 会话表（conversations）

```sql
CREATE TABLE IF NOT EXISTS conversations (
    id VARCHAR(36) PRIMARY KEY,
    type VARCHAR(20) NOT NULL, -- 'single' or 'group'
    user1_id VARCHAR(36), -- NULL for group
    user2_id VARCHAR(36), -- NULL for group
    group_id VARCHAR(36), -- NULL for single
    last_message_id VARCHAR(36),
    last_message_at TIMESTAMP,
    unread_count INTEGER NOT NULL DEFAULT 0,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(user1_id, user2_id) -- 单聊唯一约束
);

CREATE INDEX idx_conversations_user1 ON conversations(user1_id);
CREATE INDEX idx_conversations_user2 ON conversations(user2_id);
CREATE INDEX idx_conversations_group ON conversations(group_id);
CREATE INDEX idx_conversations_last_message ON conversations(last_message_at);
```

### 2.2 数据模型实现

#### 2.2.1 User 模型（已存在，需要完善）

```go
// internal/pkg/model/user.go
package model

import (
    "time"
    "gorm.io/gorm"
)

type User struct {
    ID           string    `json:"id" gorm:"primaryKey;type:varchar(36)"`
    Username     string    `json:"username" gorm:"uniqueIndex;not null;type:varchar(32)"`
    Nickname     string    `json:"nickname" gorm:"not null;type:varchar(32)"`
    Avatar       string    `json:"avatar" gorm:"not null;type:varchar(255)"`
    Email        string    `json:"email" gorm:"uniqueIndex;not null;type:varchar(255)"`
    Salt         string    `json:"-" gorm:"column:salt;not null;type:varchar(64)"`
    PasswordHash string    `json:"-" gorm:"column:password_hash;not null;type:varchar(255)"`
    Level        int       `json:"level" gorm:"not null;default:1"`
    Status       string    `json:"status" gorm:"not null;default:'active';type:varchar(20)"`
    CreatedAt    time.Time `json:"created_at"`
    UpdatedAt    time.Time `json:"updated_at"`
}

func (User) TableName() string {
    return "users"
}
```

#### 2.2.2 Message 模型

```go
// internal/pkg/model/message.go
package model

import (
    "time"
)

type Message struct {
    ID          string    `json:"id" gorm:"primaryKey;type:varchar(36)"`
    Type        string    `json:"type" gorm:"not null;type:varchar(20)"` // single, group
    FromUserID  string    `json:"from_user_id" gorm:"not null;type:varchar(36);index"`
    ToUserID    *string   `json:"to_user_id,omitempty" gorm:"type:varchar(36);index"`
    GroupID     *string   `json:"group_id,omitempty" gorm:"type:varchar(36);index"`
    Content     string    `json:"content" gorm:"not null;type:text"`
    MessageType string    `json:"message_type" gorm:"not null;default:'text';type:varchar(20)"`
    Status      string    `json:"status" gorm:"not null;default:'sent';type:varchar(20);index"`
    CreatedAt   time.Time `json:"created_at" gorm:"index"`
    UpdatedAt   time.Time `json:"updated_at"`
}

func (Message) TableName() string {
    return "messages"
}
```

#### 2.2.3 Group 模型

```go
// internal/pkg/model/group.go
package model

import (
    "time"
)

type Group struct {
    ID          string    `json:"id" gorm:"primaryKey;type:varchar(36)"`
    Name        string    `json:"name" gorm:"not null;type:varchar(100)"`
    Avatar      *string   `json:"avatar,omitempty" gorm:"type:varchar(255)"`
    Description *string   `json:"description,omitempty" gorm:"type:text"`
    OwnerID     string    `json:"owner_id" gorm:"not null;type:varchar(36);index"`
    Status      string    `json:"status" gorm:"not null;default:'active';type:varchar(20);index"`
    CreatedAt   time.Time `json:"created_at"`
    UpdatedAt   time.Time `json:"updated_at"`
}

func (Group) TableName() string {
    return "groups"
}
```

#### 2.2.4 GroupMember 模型

```go
// internal/pkg/model/group_member.go
package model

import (
    "time"
)

type GroupMember struct {
    ID        string    `json:"id" gorm:"primaryKey;type:varchar(36)"`
    GroupID   string    `json:"group_id" gorm:"not null;type:varchar(36);index"`
    UserID    string    `json:"user_id" gorm:"not null;type:varchar(36);index"`
    Role      string    `json:"role" gorm:"not null;default:'member';type:varchar(20)"`
    Status    string    `json:"status" gorm:"not null;default:'active';type:varchar(20);index"`
    JoinedAt  time.Time `json:"joined_at"`
}

func (GroupMember) TableName() string {
    return "group_members"
}
```

#### 2.2.5 Conversation 模型

```go
// internal/pkg/model/conversation.go
package model

import (
    "time"
)

type Conversation struct {
    ID            string     `json:"id" gorm:"primaryKey;type:varchar(36)"`
    Type          string     `json:"type" gorm:"not null;type:varchar(20)"`
    User1ID       *string    `json:"user1_id,omitempty" gorm:"type:varchar(36);index"`
    User2ID       *string    `json:"user2_id,omitempty" gorm:"type:varchar(36);index"`
    GroupID       *string    `json:"group_id,omitempty" gorm:"type:varchar(36);index"`
    LastMessageID *string   `json:"last_message_id,omitempty" gorm:"type:varchar(36)"`
    LastMessageAt *time.Time `json:"last_message_at,omitempty" gorm:"index"`
    UnreadCount   int        `json:"unread_count" gorm:"not null;default:0"`
    CreatedAt     time.Time  `json:"created_at"`
    UpdatedAt     time.Time  `json:"updated_at"`
}

func (Conversation) TableName() string {
    return "conversations"
}
```

### 2.3 数据库连接和迁移

```go
// internal/pkg/db/db.go
package db

import (
    "fmt"
    "github.com/HappyLadySauce/Beehive/internal/pkg/config"
    "github.com/HappyLadySauce/Beehive/internal/pkg/model"
    "gorm.io/driver/postgres"
    "gorm.io/gorm"
    "gorm.io/gorm/logger"
)

var DB *gorm.DB

func InitDB(cfg *config.DatabaseConfig) error {
    dsn := fmt.Sprintf(
        "host=%s user=%s password=%s dbname=%s port=%d sslmode=%s",
        cfg.Host, cfg.User, cfg.Password, cfg.DBName, cfg.Port, cfg.SSLMode,
    )
    
    var err error
    DB, err = gorm.Open(postgres.Open(dsn), &gorm.Config{
        Logger: logger.Default.LogMode(logger.Info),
    })
    if err != nil {
        return err
    }
    
    // 自动迁移
    return AutoMigrate()
}

func AutoMigrate() error {
    return DB.AutoMigrate(
        &model.User{},
        &model.Message{},
        &model.Group{},
        &model.GroupMember{},
        &model.Conversation{},
    )
}
```

**检查点 2.1**：数据库设计完成
- [ ] 所有表结构定义完成
- [ ] 数据模型实现完成
- [ ] 数据库连接成功
- [ ] 表自动迁移成功

## 阶段三：Protocol Buffers 定义（第7-8天）

### 3.1 定义 User Service Proto

```protobuf
// api/proto/user.proto
syntax = "proto3";

package user;

option go_package = "github.com/HappyLadySauce/Beehive/api/proto/user";

service UserService {
    rpc Register(RegisterRequest) returns (RegisterResponse);
    rpc Login(LoginRequest) returns (LoginResponse);
    rpc ValidateToken(ValidateTokenRequest) returns (ValidateTokenResponse);
    rpc GetUser(GetUserRequest) returns (GetUserResponse);
    rpc UpdateUser(UpdateUserRequest) returns (UpdateUserResponse);
}

message RegisterRequest {
    string username = 1;
    string nickname = 2;
    string email = 3;
    string password = 4;
    string avatar = 5;
}

message RegisterResponse {
    string user_id = 1;
    string token = 2;
}

message LoginRequest {
    string username = 1;
    string password = 2;
}

message LoginResponse {
    string user_id = 1;
    string token = 2;
    UserInfo user = 3;
}

message ValidateTokenRequest {
    string token = 1;
}

message ValidateTokenResponse {
    string user_id = 1;
    string username = 2;
    bool valid = 3;
}

message GetUserRequest {
    string user_id = 1;
}

message GetUserResponse {
    UserInfo user = 1;
}

message UpdateUserRequest {
    string user_id = 1;
    string nickname = 2;
    string avatar = 3;
}

message UpdateUserResponse {
    UserInfo user = 1;
}

message UserInfo {
    string id = 1;
    string username = 2;
    string nickname = 3;
    string avatar = 4;
    string email = 5;
    int32 level = 6;
    string status = 7;
}
```

### 3.2 定义 Message Service Proto

```protobuf
// api/proto/message.proto
syntax = "proto3";

package message;

option go_package = "github.com/HappyLadySauce/Beehive/api/proto/message";

service MessageService {
    rpc SendMessage(SendMessageRequest) returns (SendMessageResponse);
    rpc SendGroupMessage(SendGroupMessageRequest) returns (SendGroupMessageResponse);
    rpc GetMessageHistory(GetMessageHistoryRequest) returns (GetMessageHistoryResponse);
    rpc GetGroupMessageHistory(GetGroupMessageHistoryRequest) returns (GetGroupMessageHistoryResponse);
    rpc GetUnreadMessages(GetUnreadMessagesRequest) returns (GetUnreadMessagesResponse);
    rpc MarkAsRead(MarkAsReadRequest) returns (MarkAsReadResponse);
}

message SendMessageRequest {
    string from_user_id = 1;
    string to_user_id = 2;
    string content = 3;
    string message_type = 4; // text, image, file
}

message SendMessageResponse {
    string message_id = 1;
    int64 timestamp = 2;
}

message SendGroupMessageRequest {
    string from_user_id = 1;
    string group_id = 2;
    string content = 3;
    string message_type = 4;
}

message SendGroupMessageResponse {
    string message_id = 1;
    int64 timestamp = 2;
}

message GetMessageHistoryRequest {
    string user_id = 1;
    string target_user_id = 2;
    int32 limit = 3;
    int32 offset = 4;
}

message GetMessageHistoryResponse {
    repeated Message messages = 1;
    int32 total = 2;
}

message GetGroupMessageHistoryRequest {
    string group_id = 1;
    int32 limit = 2;
    int32 offset = 3;
}

message GetGroupMessageHistoryResponse {
    repeated Message messages = 1;
    int32 total = 2;
}

message GetUnreadMessagesRequest {
    string user_id = 1;
}

message GetUnreadMessagesResponse {
    repeated Message messages = 1;
}

message MarkAsReadRequest {
    string user_id = 1;
    repeated string message_ids = 2;
}

message MarkAsReadResponse {
    bool success = 1;
}

message Message {
    string id = 1;
    string type = 2; // single, group
    string from_user_id = 3;
    string to_user_id = 4;
    string group_id = 5;
    string content = 6;
    string message_type = 7;
    string status = 8;
    int64 timestamp = 9;
}
```

### 3.3 定义 Presence Service Proto

```protobuf
// api/proto/presence.proto
syntax = "proto3";

package presence;

option go_package = "github.com/HappyLadySauce/Beehive/api/proto/presence";

service PresenceService {
    rpc UserOnline(UserOnlineRequest) returns (UserOnlineResponse);
    rpc UserOffline(UserOfflineRequest) returns (UserOfflineResponse);
    rpc GetOnlineUsers(GetOnlineUsersRequest) returns (GetOnlineUsersResponse);
    rpc IsUserOnline(IsUserOnlineRequest) returns (IsUserOnlineResponse);
}

message UserOnlineRequest {
    string user_id = 1;
}

message UserOnlineResponse {
    bool success = 1;
}

message UserOfflineRequest {
    string user_id = 1;
}

message UserOfflineResponse {
    bool success = 1;
}

message GetOnlineUsersRequest {
    repeated string user_ids = 1;
}

message GetOnlineUsersResponse {
    repeated string user_ids = 1;
}

message IsUserOnlineRequest {
    string user_id = 1;
}

message IsUserOnlineResponse {
    bool online = 1;
}
```

### 3.4 生成 Go 代码

```bash
# 创建生成脚本
# scripts/generate-proto.sh
#!/bin/bash

PROTO_DIR="api/proto"
OUTPUT_DIR="internal/proto"

# 创建输出目录
mkdir -p ${OUTPUT_DIR}/{user,message,presence}

# 生成 User Service
protoc --go_out=${OUTPUT_DIR}/user \
       --go_opt=paths=source_relative \
       --go-grpc_out=${OUTPUT_DIR}/user \
       --go-grpc_opt=paths=source_relative \
       ${PROTO_DIR}/user.proto

# 生成 Message Service
protoc --go_out=${OUTPUT_DIR}/message \
       --go_opt=paths=source_relative \
       --go-grpc_out=${OUTPUT_DIR}/message \
       --go-grpc_opt=paths=source_relative \
       ${PROTO_DIR}/message.proto

# 生成 Presence Service
protoc --go_out=${OUTPUT_DIR}/presence \
       --go_opt=paths=source_relative \
       --go-grpc_out=${OUTPUT_DIR}/presence \
       --go-grpc_opt=paths=source_relative \
       ${PROTO_DIR}/presence.proto

echo "Proto files generated successfully!"
```

```bash
chmod +x scripts/generate-proto.sh
./scripts/generate-proto.sh
```

**检查点 3.1**：Protocol Buffers 定义完成
- [ ] 所有 proto 文件定义完成
- [ ] Go 代码生成成功
- [ ] 可以导入生成的代码

## 阶段四：gRPC 服务实现（第9-13天）

### 4.1 User Service 实现

#### 4.1.1 认证服务

```go
// internal/service/user/auth.go
package user

import (
    "crypto/rand"
    "crypto/sha256"
    "encoding/hex"
    "errors"
    "github.com/golang-jwt/jwt/v5"
    "github.com/google/uuid"
    "time"
)

type Claims struct {
    UserID   string `json:"user_id"`
    Username string `json:"username"`
    jwt.RegisteredClaims
}

func (s *Service) generateSalt() (string, error) {
    salt := make([]byte, 32)
    if _, err := rand.Read(salt); err != nil {
        return "", err
    }
    return hex.EncodeToString(salt), nil
}

func (s *Service) hashPassword(password, salt string) string {
    hash := sha256.Sum256([]byte(password + salt))
    return hex.EncodeToString(hash[:])
}

func (s *Service) GenerateToken(userID, username string) (string, error) {
    claims := &Claims{
        UserID:   userID,
        Username: username,
        RegisteredClaims: jwt.RegisteredClaims{
            ExpiresAt: jwt.NewNumericDate(time.Now().Add(time.Duration(s.config.JWT.ExpireHours) * time.Hour)),
            IssuedAt:  jwt.NewNumericDate(time.Now()),
            NotBefore: jwt.NewNumericDate(time.Now()),
        },
    }
    
    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
    return token.SignedString([]byte(s.config.JWT.Secret))
}

func (s *Service) ValidateToken(tokenString string) (*Claims, error) {
    token, err := jwt.ParseWithClaims(tokenString, &Claims{}, func(token *jwt.Token) (interface{}, error) {
        return []byte(s.config.JWT.Secret), nil
    })
    
    if err != nil {
        return nil, err
    }
    
    if claims, ok := token.Claims.(*Claims); ok && token.Valid {
        return claims, nil
    }
    
    return nil, errors.New("invalid token")
}
```

#### 4.1.2 User Service 实现

```go
// internal/service/user/service.go
package user

import (
    "context"
    "errors"
    "github.com/HappyLadySauce/Beehive/internal/pkg/db"
    "github.com/HappyLadySauce/Beehive/internal/pkg/model"
    "github.com/google/uuid"
    "google.golang.org/grpc/codes"
    "google.golang.org/grpc/status"
    pb "github.com/HappyLadySauce/Beehive/internal/proto/user"
)

type Service struct {
    pb.UnimplementedUserServiceServer
    config *config.Config
}

func NewService(cfg *config.Config) *Service {
    return &Service{
        config: cfg,
    }
}

func (s *Service) Register(ctx context.Context, req *pb.RegisterRequest) (*pb.RegisterResponse, error) {
    // 检查用户名是否已存在
    var existingUser model.User
    if err := db.DB.Where("username = ?", req.Username).First(&existingUser).Error; err == nil {
        return nil, status.Error(codes.AlreadyExists, "username already exists")
    }
    
    // 检查邮箱是否已存在
    if err := db.DB.Where("email = ?", req.Email).First(&existingUser).Error; err == nil {
        return nil, status.Error(codes.AlreadyExists, "email already exists")
    }
    
    // 生成盐值和密码哈希
    salt, err := s.generateSalt()
    if err != nil {
        return nil, status.Error(codes.Internal, "failed to generate salt")
    }
    
    passwordHash := s.hashPassword(req.Password, salt)
    
    // 创建用户
    user := &model.User{
        ID:           uuid.New().String(),
        Username:     req.Username,
        Nickname:     req.Nickname,
        Avatar:       req.Avatar,
        Email:        req.Email,
        Salt:         salt,
        PasswordHash: passwordHash,
        Level:        1,
        Status:       "active",
    }
    
    if err := db.DB.Create(user).Error; err != nil {
        return nil, status.Error(codes.Internal, "failed to create user")
    }
    
    // 生成 Token
    token, err := s.GenerateToken(user.ID, user.Username)
    if err != nil {
        return nil, status.Error(codes.Internal, "failed to generate token")
    }
    
    return &pb.RegisterResponse{
        UserId: user.ID,
        Token:  token,
    }, nil
}

func (s *Service) Login(ctx context.Context, req *pb.LoginRequest) (*pb.LoginResponse, error) {
    var user model.User
    if err := db.DB.Where("username = ?", req.Username).First(&user).Error; err != nil {
        return nil, status.Error(codes.NotFound, "user not found")
    }
    
    // 验证密码
    passwordHash := s.hashPassword(req.Password, user.Salt)
    if passwordHash != user.PasswordHash {
        return nil, status.Error(codes.Unauthenticated, "invalid password")
    }
    
    // 检查用户状态
    if user.Status != "active" {
        return nil, status.Error(codes.PermissionDenied, "user is not active")
    }
    
    // 生成 Token
    token, err := s.GenerateToken(user.ID, user.Username)
    if err != nil {
        return nil, status.Error(codes.Internal, "failed to generate token")
    }
    
    return &pb.LoginResponse{
        UserId: user.ID,
        Token:  token,
        User: &pb.UserInfo{
            Id:       user.ID,
            Username: user.Username,
            Nickname: user.Nickname,
            Avatar:   user.Avatar,
            Email:    user.Email,
            Level:    int32(user.Level),
            Status:   user.Status,
        },
    }, nil
}

func (s *Service) ValidateToken(ctx context.Context, req *pb.ValidateTokenRequest) (*pb.ValidateTokenResponse, error) {
    claims, err := s.ValidateToken(req.Token)
    if err != nil {
        return &pb.ValidateTokenResponse{
            Valid: false,
        }, nil
    }
    
    return &pb.ValidateTokenResponse{
        UserId:   claims.UserID,
        Username: claims.Username,
        Valid:    true,
    }, nil
}

func (s *Service) GetUser(ctx context.Context, req *pb.GetUserRequest) (*pb.GetUserResponse, error) {
    var user model.User
    if err := db.DB.Where("id = ?", req.UserId).First(&user).Error; err != nil {
        return nil, status.Error(codes.NotFound, "user not found")
    }
    
    return &pb.GetUserResponse{
        User: &pb.UserInfo{
            Id:       user.ID,
            Username: user.Username,
            Nickname: user.Nickname,
            Avatar:   user.Avatar,
            Email:    user.Email,
            Level:    int32(user.Level),
            Status:   user.Status,
        },
    }, nil
}
```

#### 4.1.3 User Service 入口

```go
// cmd/user-service/main.go
package main

import (
    "log"
    "net"
    "github.com/HappyLadySauce/Beehive/internal/pkg/config"
    "github.com/HappyLadySauce/Beehive/internal/pkg/db"
    "github.com/HappyLadySauce/Beehive/internal/service/user"
    pb "github.com/HappyLadySauce/Beehive/internal/proto/user"
    "google.golang.org/grpc"
)

func main() {
    // 加载配置
    cfg, err := config.LoadConfig(".")
    if err != nil {
        log.Fatalf("Failed to load config: %v", err)
    }
    
    // 初始化数据库
    if err := db.InitDB(&cfg.Database); err != nil {
        log.Fatalf("Failed to init database: %v", err)
    }
    
    // 创建服务
    userService := user.NewService(cfg)
    
    // 启动 gRPC 服务器
    lis, err := net.Listen("tcp", fmt.Sprintf(":%d", cfg.Server.UserServicePort))
    if err != nil {
        log.Fatalf("Failed to listen: %v", err)
    }
    
    s := grpc.NewServer()
    pb.RegisterUserServiceServer(s, userService)
    
    log.Printf("User Service listening on :%d", cfg.Server.UserServicePort)
    if err := s.Serve(lis); err != nil {
        log.Fatalf("Failed to serve: %v", err)
    }
}
```

**检查点 4.1**：User Service 完成
- [ ] 用户注册功能
- [ ] 用户登录功能
- [ ] Token 验证功能
- [ ] 服务可以正常启动

### 4.2 Message Service 实现

（类似实现，参考 User Service 的结构）

### 4.3 Presence Service 实现

（类似实现，参考 User Service 的结构）

## 阶段五：WebSocket Gateway（第14-18天）

### 5.1 Gateway Service 入口（使用 Cobra）

```go
// cmd/gateway/main.go
package main

import (
    "os"
    "github.com/HappyLadySauce/Beehive/cmd/gateway/cmd"
)

func main() {
    command := cmd.NewGatewayCommand()
    if err := command.Execute(); err != nil {
        os.Exit(1)
    }
}
```

### 5.2 Gateway Service Cobra 命令实现

```go
// cmd/gateway/cmd/root.go
package cmd

import (
    "fmt"
    "github.com/spf13/cobra"
    "github.com/HappyLadySauce/Beehive/pkg/options"
    "github.com/HappyLadySauce/Beehive/internal/pkg/config"
)

var (
    cfgFile string
    cfg     *config.Config
)

func NewGatewayCommand() *cobra.Command {
    cmd := &cobra.Command{
        Use:   "gateway",
        Short: "WebSocket Gateway for Beehive IM",
        Long:  `WebSocket Gateway handles client connections and message routing.`,
        PersistentPreRunE: func(cmd *cobra.Command, args []string) error {
            var err error
            cfg, err = config.LoadConfig(".")
            if err != nil {
                return fmt.Errorf("failed to load config: %w", err)
            }
            return nil
        },
    }
    
    options.AddConfigFlag("gateway", cmd.PersistentFlags())
    
    cmd.AddCommand(NewServeCommand())
    cmd.AddCommand(NewVersionCommand())
    
    return cmd
}

// cmd/gateway/cmd/serve.go
package cmd

import (
    "context"
    "fmt"
    "log"
    "net/http"
    "os"
    "os/signal"
    "syscall"
    "github.com/spf13/cobra"
    "github.com/HappyLadySauce/Beehive/internal/gateway/websocket"
    "github.com/HappyLadySauce/Beehive/internal/gateway/connection"
    "github.com/HappyLadySauce/Beehive/internal/mq"
)

func NewServeCommand() *cobra.Command {
    cmd := &cobra.Command{
        Use:   "serve",
        Short: "Start the gateway service",
        RunE: func(cmd *cobra.Command, args []string) error {
            return runServe()
        },
    }
    
    return cmd
}

func runServe() error {
    // 初始化连接管理器
    connMgr := connection.NewManager()
    
    // 初始化 RabbitMQ Consumer
    consumer, err := mq.NewConsumer(cfg.RabbitMQ.URL, connMgr, "gateway-1")
    if err != nil {
        return fmt.Errorf("failed to create consumer: %w", err)
    }
    
    // 启动消息消费者
    go consumer.ConsumeSingleChatMessages()
    go consumer.ConsumeGroupMessages()
    go consumer.ConsumePresenceMessages()
    
    // 创建 WebSocket Handler
    handler := websocket.NewHandler(connMgr, cfg)
    
    // 设置路由
    http.HandleFunc("/ws", handler.HandleConnection)
    http.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) {
        w.WriteHeader(http.StatusOK)
        w.Write([]byte("OK"))
    })
    
    // 启动 HTTP 服务器
    server := &http.Server{
        Addr: fmt.Sprintf(":%d", cfg.Server.GatewayPort),
    }
    
    // 优雅关闭
    ctx, cancel := context.WithCancel(context.Background())
    defer cancel()
    
    go func() {
        sigChan := make(chan os.Signal, 1)
        signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)
        <-sigChan
        log.Println("Shutting down server...")
        server.Shutdown(ctx)
        cancel()
    }()
    
    log.Printf("Gateway listening on :%d", cfg.Server.GatewayPort)
    if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
        return fmt.Errorf("failed to serve: %w", err)
    }
    
    <-ctx.Done()
    return nil
}
```

### 5.3 Connection Manager

（参考文档 02-WebSocket-Gateway设计.md）

### 5.4 WebSocket Handler

（参考文档 02-WebSocket-Gateway设计.md）

## 阶段六：RabbitMQ 集成（第19-23天）

### 6.1 Producer 实现

（参考文档 03-消息队列设计.md）

### 6.2 Consumer 实现

（参考文档 03-消息队列设计.md）

## 阶段七：测试和优化（第24-30天）

### 7.1 单元测试

```go
// internal/service/user/service_test.go
package user

import (
    "testing"
    // ...
)

func TestService_Register(t *testing.T) {
    // 测试用例
}
```

### 7.2 集成测试

### 7.3 性能测试

### 7.4 优化

## 每日开发检查清单

### 第1天：环境搭建
- [ ] Go 环境配置
- [ ] Docker 环境配置
- [ ] 项目结构创建
- [ ] 依赖安装

### 第2天：配置和数据库
- [ ] 配置文件实现
- [ ] 数据库表设计
- [ ] 数据模型实现
- [ ] 数据库连接测试

### 第3-4天：Protocol Buffers
- [ ] Proto 文件定义
- [ ] 代码生成
- [ ] 验证生成代码

### 第5-9天：gRPC 服务
- [ ] User Service 实现
- [ ] Message Service 实现
- [ ] Presence Service 实现
- [ ] 服务测试

### 第10-13天：WebSocket Gateway
- [ ] Connection Manager
- [ ] WebSocket Handler
- [ ] 消息处理逻辑
- [ ] 集成测试

### 第14-16天：RabbitMQ
- [ ] Producer 实现
- [ ] Consumer 实现
- [ ] Exchange 和 Queue 配置
- [ ] 消息路由测试

### 第17-20天：功能完善
- [ ] 离线消息处理
- [ ] 群聊功能
- [ ] 在线状态
- [ ] 错误处理

### 第21-25天：测试和优化
- [ ] 单元测试
- [ ] 集成测试
- [ ] 性能优化
- [ ] 文档完善

## 常见问题排查

### 问题1：数据库连接失败
- 检查 Docker 容器是否运行
- 检查连接配置
- 检查网络端口

### 问题2：gRPC 服务启动失败
- 检查端口是否被占用
- 检查 proto 文件是否正确生成
- 检查依赖是否正确安装

### 问题3：RabbitMQ 连接失败
- 检查 RabbitMQ 容器状态
- 检查连接 URL
- 检查 Exchange 和 Queue 是否创建

## 下一步

完成基础功能后，可以考虑：
1. 添加文件上传功能
2. 实现消息撤回
3. 添加消息搜索
4. 实现消息加密
5. 添加管理后台
6. 实现分布式部署

## 参考文档

- [用户登录与操作逻辑](./01-用户登录与操作逻辑.md)
- [WebSocket Gateway 设计](./02-WebSocket-Gateway设计.md)
- [消息队列设计](./03-消息队列设计.md)