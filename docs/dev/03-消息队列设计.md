# 消息队列设计文档

## 概述

本文档详细说明 IM 系统中 RabbitMQ 消息队列的设计，包括 Exchange、Queue、Routing Key 的配置，以及单聊、群聊消息的路由机制。

## RabbitMQ 架构概览

```mermaid
graph TB
    subgraph Producer["消息生产者"]
        MS[Message Service]
    end
    
    subgraph RabbitMQ["RabbitMQ"]
        subgraph Exchanges["Exchange 交换机"]
            DirectEx[im.direct<br/>Direct Exchange<br/>单聊消息]
            TopicEx[im.topic<br/>Topic Exchange<br/>群聊消息]
            PresenceEx[im.presence<br/>Fanout Exchange<br/>在线状态]
        end
        
        subgraph Queues["Queue 队列"]
            UserQ1[queue.user.user1]
            UserQ2[queue.user.user2]
            GroupQ1[queue.group.group1]
            GroupQ2[queue.group.group2]
            GatewayQ1[queue.gateway.gw1.single]
            GatewayQ2[queue.gateway.gw2.single]
            PresenceQ1[queue.presence.gw1]
            PresenceQ2[queue.presence.gw2]
        end
    end
    
    subgraph Consumer["消息消费者"]
        C1[Gateway 1 Consumer]
        C2[Gateway 2 Consumer]
    end
    
    MS -->|"routing: user.user2"| DirectEx
    MS -->|"routing: group.group1"| TopicEx
    MS -->|"广播"| PresenceEx
    
    DirectEx -->|"精确匹配"| UserQ1
    DirectEx -->|"精确匹配"| UserQ2
    DirectEx -->|"模式匹配"| GatewayQ1
    DirectEx -->|"模式匹配"| GatewayQ2
    
    TopicEx -->|"模式匹配"| GroupQ1
    TopicEx -->|"模式匹配"| GroupQ2
    TopicEx -->|"模式匹配"| GatewayQ1
    TopicEx -->|"模式匹配"| GatewayQ2
    
    PresenceEx -->|"广播"| PresenceQ1
    PresenceEx -->|"广播"| PresenceQ2
    
    UserQ1 --> C1
    UserQ2 --> C2
    GroupQ1 --> C1
    GroupQ2 --> C2
    GatewayQ1 --> C1
    GatewayQ2 --> C2
    PresenceQ1 --> C1
    PresenceQ2 --> C2
```

## Exchange 设计

### 1. im.direct - 单聊消息 Exchange

**类型**：Direct Exchange  
**特点**：精确匹配 routing key，用于点对点消息路由

#### 配置

```go
// internal/mq/config.go
func SetupDirectExchange(ch *amqp.Channel) error {
    return ch.ExchangeDeclare(
        "im.direct",        // exchange name
        "direct",           // exchange type
        true,               // durable (持久化)
        false,              // auto-deleted
        false,              // internal
        false,              // no-wait
        nil,                // arguments
    )
}
```

#### Routing Key 规则

- **格式**：`user.{targetUserID}`
- **示例**：
  - 发送给用户 `user123`：`user.user123`
  - 发送给用户 `user456`：`user.user456`

#### 使用场景

```go
// internal/mq/producer.go
func (p *Producer) PublishSingleChatMessage(targetUserID string, message *pb.Message) error {
    routingKey := fmt.Sprintf("user.%s", targetUserID)
    
    messageBytes, err := proto.Marshal(message)
    if err != nil {
        return err
    }
    
    return p.channel.Publish(
        "im.direct",        // exchange
        routingKey,         // routing key
        false,              // mandatory
        false,              // immediate
        amqp.Publishing{
            ContentType:  "application/x-protobuf",
            Body:         messageBytes,
            Persistent:   true,              // 消息持久化
            DeliveryMode: amqp.Persistent,   // 持久化模式
            MessageId:    message.Id,
            Timestamp:    time.Now(),
            Headers: amqp.Table{
                "from_user_id": message.FromUserID,
                "to_user_id":   message.ToUserID,
                "message_type": message.MessageType,
            },
        },
    )
}
```

### 2. im.topic - 群聊消息 Exchange

**类型**：Topic Exchange  
**特点**：支持模式匹配，用于群组消息广播

#### 配置

```go
func SetupTopicExchange(ch *amqp.Channel) error {
    return ch.ExchangeDeclare(
        "im.topic",
        "topic",
        true,
        false,
        false,
        false,
        nil,
    )
}
```

#### Routing Key 规则

- **格式**：`group.{groupID}`
- **模式匹配**：
  - `group.*`：匹配所有群组消息
  - `group.group1`：精确匹配群组 group1
- **示例**：
  - 群组 `group123`：`group.group123`
  - 群组 `group456`：`group.group456`

#### 使用场景

```go
func (p *Producer) PublishGroupMessage(groupID string, message *pb.Message) error {
    routingKey := fmt.Sprintf("group.%s", groupID)
    
    messageBytes, err := proto.Marshal(message)
    if err != nil {
        return err
    }
    
    return p.channel.Publish(
        "im.topic",
        routingKey,
        false,
        false,
        amqp.Publishing{
            ContentType:  "application/x-protobuf",
            Body:         messageBytes,
            Persistent:   true,
            DeliveryMode: amqp.Persistent,
            MessageId:    message.Id,
            Timestamp:    time.Now(),
            Headers: amqp.Table{
                "group_id":    message.GroupID,
                "from_user_id": message.FromUserID,
                "message_type": message.MessageType,
            },
        },
    )
}
```

### 3. im.presence - 在线状态 Exchange

**类型**：Fanout Exchange  
**特点**：广播到所有绑定的队列，忽略 routing key

#### 配置

```go
func SetupPresenceExchange(ch *amqp.Channel) error {
    return ch.ExchangeDeclare(
        "im.presence",
        "fanout",
        true,
        false,
        false,
        false,
        nil,
    )
}
```

#### 使用场景

```go
func (p *Producer) PublishPresenceEvent(event *pb.PresenceEvent) error {
    eventBytes, err := proto.Marshal(event)
    if err != nil {
        return err
    }
    
    return p.channel.Publish(
        "im.presence",
        "",  // fanout 类型忽略 routing key
        false,
        false,
        amqp.Publishing{
            ContentType:  "application/x-protobuf",
            Body:         eventBytes,
            Persistent:   true,
            DeliveryMode: amqp.Persistent,
            Timestamp:    time.Now(),
        },
    )
}
```

## Queue 设计

### 1. 用户队列（单聊消息）

#### 设计思路

**方案 A：每个用户一个队列（不推荐）**
- 优点：消息路由精确
- 缺点：用户数量大时队列过多，管理复杂

**方案 B：Gateway 队列 + 动态绑定（推荐）**
- 每个 Gateway 实例创建一个队列
- 使用 routing key 模式匹配绑定所有用户消息
- 优点：队列数量可控，易于管理
- 缺点：需要 Gateway 过滤不属于自己的消息

#### 实现（方案 B）

```go
// internal/mq/consumer.go
func (c *Consumer) SetupSingleChatQueue() error {
    // 为当前 Gateway 创建队列
    queueName := fmt.Sprintf("queue.gateway.%s.single", c.gatewayID)
    
    _, err := c.channel.QueueDeclare(
        queueName,
        true,  // durable
        false, // delete when unused
        false, // exclusive
        false, // no-wait
        amqp.Table{
            "x-message-ttl":          86400000,  // 消息TTL 24小时
            "x-max-length":          10000,     // 最大消息数
            "x-overflow":            "drop-head", // 溢出策略
            "x-dead-letter-exchange": "im.dlx",  // 死信队列
        },
    )
    if err != nil {
        return err
    }
    
    // 绑定到 direct exchange，使用通配符（需要 RabbitMQ 支持）
    // 注意：Direct Exchange 不支持通配符，需要使用 Topic Exchange
    // 或者为每个在线用户动态创建绑定
    
    // 方案：使用 Topic Exchange 替代 Direct Exchange
    err = c.channel.QueueBind(
        queueName,
        "user.*",  // 匹配所有用户消息
        "im.direct", // 实际上应该改为 im.topic
        false,
        nil,
    )
    
    return err
}
```

**更好的方案：使用 Topic Exchange 处理单聊**

```go
// 修改 Exchange 设计：单聊也使用 Topic Exchange
func SetupSingleChatExchange(ch *amqp.Channel) error {
    return ch.ExchangeDeclare(
        "im.single",  // 改为 topic 类型
        "topic",
        true,
        false,
        false,
        false,
        nil,
    )
}

// 发送单聊消息
func (p *Producer) PublishSingleChatMessage(targetUserID string, message *pb.Message) error {
    routingKey := fmt.Sprintf("user.%s", targetUserID)
    return p.channel.Publish(
        "im.single",  // 使用 topic exchange
        routingKey,
        false,
        false,
        amqp.Publishing{
            // ...
        },
    )
}

// Gateway 队列绑定
func (c *Consumer) SetupSingleChatQueue() error {
    queueName := fmt.Sprintf("queue.gateway.%s.single", c.gatewayID)
    
    _, err := c.channel.QueueDeclare(queueName, true, false, false, false, nil)
    if err != nil {
        return err
    }
    
    // 绑定到 topic exchange，匹配所有用户消息
    return c.channel.QueueBind(
        queueName,
        "user.*",  // 匹配所有用户消息
        "im.single",
        false,
        nil,
    )
}
```

### 2. 群组队列（群聊消息）

```go
func (c *Consumer) SetupGroupQueue() error {
    queueName := fmt.Sprintf("queue.gateway.%s.group", c.gatewayID)
    
    _, err := c.channel.QueueDeclare(
        queueName,
        true,
        false,
        false,
        false,
        amqp.Table{
            "x-message-ttl": 86400000,
        },
    )
    if err != nil {
        return err
    }
    
    // 绑定到 topic exchange，匹配所有群组消息
    return c.channel.QueueBind(
        queueName,
        "group.*",  // 匹配所有群组消息
        "im.topic",
        false,
        nil,
    )
}
```

### 3. 在线状态队列

```go
func (c *Consumer) SetupPresenceQueue() error {
    queueName := fmt.Sprintf("queue.presence.%s", c.gatewayID)
    
    _, err := c.channel.QueueDeclare(
        queueName,
        true,
        true,  // auto-delete: Gateway 下线时自动删除
        false,
        false,
        nil,
    )
    if err != nil {
        return err
    }
    
    // 绑定到 fanout exchange
    return c.channel.QueueBind(
        queueName,
        "",  // fanout 忽略 routing key
        "im.presence",
        false,
        nil,
    )
}
```

## 消息流转流程

### 单聊消息完整流程

```mermaid
sequenceDiagram
    participant Client as 客户端A
    participant Gateway as WebSocket Gateway
    participant MsgSvc as Message Service
    participant DB as 数据库
    participant MQ as RabbitMQ
    participant Consumer as MQ Consumer
    participant ConnMgr as Connection Manager
    participant TargetClient as 客户端B
    
    Client->>Gateway: 发送消息
    Gateway->>MsgSvc: gRPC: SendMessage
    MsgSvc->>DB: 保存消息
    MsgSvc->>MQ: Publish to im.single<br/>routing: user.userB
    MQ->>MQ: 路由到 queue.gateway.*.single
    MQ->>Consumer: 消费消息
    Consumer->>Consumer: 解析消息，提取 to_user_id
    Consumer->>ConnMgr: GetUserConnections(userB)
    ConnMgr-->>Consumer: 返回连接列表
    alt 用户B在线
        Consumer->>TargetClient: 推送消息
        Consumer->>MQ: Ack消息
    else 用户B离线
        Consumer->>DB: 标记为未读
        Consumer->>MQ: Ack消息
    end
```

### 群聊消息完整流程

```mermaid
sequenceDiagram
    participant Client as 客户端A
    participant Gateway as WebSocket Gateway
    participant MsgSvc as Message Service
    participant DB as 数据库
    participant MQ as RabbitMQ
    participant Consumer as MQ Consumer
    participant ConnMgr as Connection Manager
    participant Members as 群组成员客户端
    
    Client->>Gateway: 发送群消息
    Gateway->>MsgSvc: gRPC: SendGroupMessage
    MsgSvc->>DB: 查询群组成员
    MsgSvc->>DB: 保存消息
    MsgSvc->>MQ: Publish to im.topic<br/>routing: group.group1
    MQ->>MQ: 路由到 queue.gateway.*.group
    MQ->>Consumer: 消费消息
    Consumer->>Consumer: 解析消息，提取 group_id
    Consumer->>DB: 查询群组在线成员
    loop 每个在线成员
        Consumer->>ConnMgr: GetUserConnections(memberID)
        ConnMgr-->>Consumer: 返回连接
        Consumer->>Members: 推送消息
    end
    Consumer->>DB: 标记离线成员消息为未读
    Consumer->>MQ: Ack消息
```

## 消息确认机制

### 手动确认（Manual Acknowledgment）

```go
// 消费消息时设置手动确认
msgs, err := c.channel.Consume(
    queueName,
    "",
    false, // auto-ack = false，手动确认
    false,
    false,
    false,
    nil,
)

// 处理消息
for msg := range msgs {
    if err := c.handleMessage(msg); err != nil {
        // 处理失败，拒绝消息并重新入队
        msg.Nack(false, true)
    } else {
        // 处理成功，确认消息
        msg.Ack(false)
    }
}
```

### 消息重试机制

```go
func (c *Consumer) handleMessageWithRetry(delivery amqp.Delivery, maxRetries int) {
    retryCount := 0
    
    for {
        err := c.handleMessage(delivery)
        if err == nil {
            delivery.Ack(false)
            return
        }
        
        retryCount++
        if retryCount >= maxRetries {
            // 超过重试次数，发送到死信队列
            delivery.Nack(false, false)
            return
        }
        
        // 等待后重试
        time.Sleep(time.Duration(retryCount) * time.Second)
    }
}
```

## 死信队列（DLX）

处理无法正常消费的消息。

```go
// 设置死信队列
func SetupDeadLetterExchange(ch *amqp.Channel) error {
    // 声明死信 Exchange
    err := ch.ExchangeDeclare(
        "im.dlx",
        "topic",
        true,
        false,
        false,
        false,
        nil,
    )
    if err != nil {
        return err
    }
    
    // 声明死信队列
    _, err = ch.QueueDeclare(
        "queue.dlx",
        true,
        false,
        false,
        false,
        nil,
    )
    if err != nil {
        return err
    }
    
    // 绑定死信队列
    return ch.QueueBind(
        "queue.dlx",
        "#",  // 匹配所有 routing key
        "im.dlx",
        false,
        nil,
    )
}

// 在普通队列中配置死信队列
_, err := ch.QueueDeclare(
    queueName,
    true,
    false,
    false,
    false,
    amqp.Table{
        "x-dead-letter-exchange":    "im.dlx",
        "x-dead-letter-routing-key": "failed.message",
        "x-message-ttl":             86400000,
        "x-max-retries":             3,
    },
)
```

## 性能优化

### 1. 消息批量处理

```go
// 批量确认消息
func (c *Consumer) ConsumeWithBatchAck() {
    const batchSize = 100
    var batch []amqp.Delivery
    
    for msg := range msgs {
        batch = append(batch, msg)
        
        if len(batch) >= batchSize {
            c.processBatch(batch)
            // 批量确认
            for _, delivery := range batch {
                delivery.Ack(false)
            }
            batch = batch[:0]
        }
    }
    
    // 处理剩余消息
    if len(batch) > 0 {
        c.processBatch(batch)
        for _, delivery := range batch {
            delivery.Ack(false)
        }
    }
}
```

### 2. 预取数量（Prefetch Count）

```go
// 设置预取数量，控制未确认消息数
err := c.channel.Qos(
    100,  // prefetch count
    0,    // prefetch size
    false, // global
)
```

### 3. 连接池

```go
// 使用连接池管理 RabbitMQ 连接
type ConnectionPool struct {
    connections chan *amqp.Connection
    mu          sync.Mutex
}

func (p *ConnectionPool) GetConnection() (*amqp.Connection, error) {
    select {
    case conn := <-p.connections:
        if conn.IsClosed() {
            // 连接已关闭，创建新连接
            return amqp.Dial(amqpURL)
        }
        return conn, nil
    default:
        // 池中没有连接，创建新连接
        return amqp.Dial(amqpURL)
    }
}
```

## 监控和告警

### 关键指标

1. **队列长度**：监控队列中未消费的消息数
2. **消费速率**：每秒消费的消息数
3. **消息延迟**：消息从生产到消费的时间
4. **错误率**：消息处理失败率

### 监控实现

```go
// 获取队列信息
func GetQueueInfo(ch *amqp.Channel, queueName string) (*amqp.Queue, error) {
    return ch.QueueInspect(queueName)
}

// 定期检查队列长度
func MonitorQueue(ch *amqp.Channel, queueName string) {
    ticker := time.NewTicker(30 * time.Second)
    defer ticker.Stop()
    
    for range ticker.C {
        queue, err := ch.QueueInspect(queueName)
        if err != nil {
            log.Printf("Failed to inspect queue: %v", err)
            continue
        }
        
        if queue.Messages > 10000 {
            // 告警：队列积压
            log.Printf("WARNING: Queue %s has %d messages", queueName, queue.Messages)
        }
    }
}
```

## 配置示例

### RabbitMQ 初始化

```go
// internal/mq/config.go
func InitializeRabbitMQ(amqpURL string) (*amqp.Connection, error) {
    conn, err := amqp.Dial(amqpURL)
    if err != nil {
        return nil, err
    }
    
    ch, err := conn.Channel()
    if err != nil {
        return nil, err
    }
    defer ch.Close()
    
    // 设置 Exchange
    if err := SetupSingleChatExchange(ch); err != nil {
        return nil, err
    }
    if err := SetupTopicExchange(ch); err != nil {
        return nil, err
    }
    if err := SetupPresenceExchange(ch); err != nil {
        return nil, err
    }
    if err := SetupDeadLetterExchange(ch); err != nil {
        return nil, err
    }
    
    return conn, nil
}
```

### 环境变量配置

```bash
# RabbitMQ 连接配置
RABBITMQ_URL=amqp://guest:guest@localhost:5672/
RABBITMQ_EXCHANGE_SINGLE=im.single
RABBITMQ_EXCHANGE_TOPIC=im.topic
RABBITMQ_EXCHANGE_PRESENCE=im.presence
RABBITMQ_PREFETCH_COUNT=100
```